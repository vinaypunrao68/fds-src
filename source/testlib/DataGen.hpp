/*
 * Copyright 2014 Formation Data Systems, Inc.
 */
#ifndef SOURCE_INCLUDE_DATAGEN_H_  // NOLINT
#define SOURCE_INCLUDE_DATAGEN_H_

#include <string>
#include <algorithm>
#include <boost/shared_ptr.hpp>
#include <boost/make_shared.hpp>

namespace fds {

typedef boost::shared_ptr<std::string> StringPtr;

/**
* @brief Generic data generation interface
*/
struct DataGenIf {
    virtual ~DataGenIf() {}
    virtual StringPtr nextItem() = 0;
    virtual bool hasNext()
    {
        return true;
    }
    virtual void reset() {}
};
typedef boost::shared_ptr<DataGenIf> DataGenIfPtr;

/**
* @brief Functor for generating alpha numeric string
*/
struct RandAlphaNumStringF
{
    StringPtr operator() (const size_t &sz)
    {
        auto randchar = []() -> char
        {
            const char charset[] =
                "0123456789"
                "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                "abcdefghijklmnopqrstuvwxyz";
            const size_t max_index = (sizeof(charset) - 1);
            return charset[ rand() % max_index ];  // NOLINT
        };
        auto str = boost::make_shared<std::string>(sz, 0);
        std::generate_n(str->begin(), sz, randchar);
        return str;
    }
};

/**
* @brief Generates random data
*
* @tparam RandDataFuncT Function that generates random data.  This
* functor must take size as argument
*/
template <class RandDataFuncT = RandAlphaNumStringF>
struct RandDataGenerator : DataGenIf
{
    RandDataGenerator(int32_t count, size_t min, size_t max)
    {
        maxCount_ = count;
        curCnt_ = 0;
        min_ = min;
        max_ = max;
    }
    RandDataGenerator(size_t min, size_t max)
    :RandDataGenerator(-1, min, max) 
    {
    }
    virtual StringPtr nextItem() override
    {
        if (maxCount_ != -1 && curCnt_ >= maxCount_) {
            return nullptr;
        }
        curCnt_++;
        size_t sz = (rand() % ((max_ - min_)+1)) + min_;  // NOLINT
        return randDataF_(sz);
    }
    virtual bool hasNext()
    {
        return (maxCount_ == -1 || curCnt_ < maxCount_);
    }
    virtual void reset() {
        curCnt_ = 0;
    }
 protected:
    /* Number of items to produce. -1 to indicate unlimited */
    int32_t maxCount_;
    /* # of times nextItem has been called */
    int32_t curCnt_;
    /* Minimum size for the data returned by nextItem() */
    size_t min_;
    /* Minimum size for the data returned by nextItem() */
    size_t max_;
    /* Function that generates the random data */
    RandDataFuncT randDataF_;
};

/**
* @brief Generates random data and caches it.  Use it if you don't want to incur generation
* cost
*
* @tparam RandDataFuncT Function that generates random data.  This
* functor must take size as argument
*/
template <class RandDataFuncT = RandAlphaNumStringF>
struct CachedRandDataGenerator : DataGenIf
{
    /**
    * @brief Constructor
    *
    * @param count Number of items in the cache
    * @param wrapAround To wrap around once the last element is reached when nextItem()
    * is called
    * @param min minumum size of data to generate
    * @param max maximum size of data to generate
    */
    CachedRandDataGenerator(int count, bool wrapAround, size_t min, size_t max)
    {
        wrapAround_ = wrapAround;
        items_.resize(count);
        for (int i = 0; i < count; i++) {
            size_t sz = (rand() % ((max - min)+1)) + min;  // NOLINT
            items_[i] = randDataF_(sz);
        }
    }
    virtual StringPtr nextItem() override
    {
        auto idx = idx_++;
        if (wrapAround_) {
            idx = idx % items_.size();
        }
        return items_[idx];
    }
    virtual bool hasNext()
    {
        if (wrapAround_) {
            return true;
        }
        return idx_ < items_.size();
    }
    virtual void reset() override {
        idx_ = 0;
    }
    StringPtr itemAt(uint32_t idx) {
        return items_[idx % items_.size()];
    }
 protected:
    /* Cached items */
    std::vector<StringPtr> items_;
    /* Current index. nextItem() will return item from this index */
    uint32_t idx_;
    /* To wrap around the items_ array or not */
    bool wrapAround_;
    /* Functor to generate data */
    RandDataFuncT randDataF_;
};

/**
* @brief For generating svc messages
*
* @tparam MsgT Message type generated by SvcMsgGenerator
*/
template <class MsgT>
struct SvcMsgGenerator
{
    SvcMsgGenerator(std::function<boost::shared_ptr<MsgT> ()> genF)
        : genF_(genF)
    {
    }
    virtual boost::shared_ptr<MsgT> nextItem()
    {
        return genF_();
    }
    virtual bool hasNext()
    {
        return true;
    }

 protected:
    std::function<boost::shared_ptr<MsgT> ()> genF_;
};

/**
* @brief Generates messages and caches them.
*
* @tparam MsgT Message type generated by CachedMsgGenerator
*/
template <class MsgT>
struct CachedMsgGenerator : SvcMsgGenerator<MsgT>
{
    /**
    * @brief Constructor
    *
    * @param count Number of items in the cache
    * @param wrapAround To wrap around once the last element is reached when nextItem()
    * is called
    * @param generator function to gene
    */
    CachedMsgGenerator(int count, bool wrapAround,
                       std::function<boost::shared_ptr<MsgT> ()> genF)
        : SvcMsgGenerator<MsgT>(genF) 
    {
        wrapAround_ = wrapAround;
        items_.resize(count);
        for (int i = 0; i < count; i++) {
            items_[i] = genF();
        }
    }
    virtual boost::shared_ptr<MsgT> nextItem()
    {
        auto idx = idx_++;
        if (wrapAround_) {
            idx = idx % items_.size();
        }
        return items_[idx];
    }
    virtual bool hasNext()
    {
        if (wrapAround_) {
            return true;
        }
        return idx_ < items_.size();
    }
 protected:
    /* Cached items */
    std::vector<boost::shared_ptr<MsgT>> items_;
    /* Current index. nextItem() will return item from this index */
    uint32_t idx_;
    /* To wrap around the items_ array or not */
    bool wrapAround_;
};

/**
 * Generates fix sized unique data;
 */
class SequentialBlobDataGen {
  public:
    /// size of blob data
    fds_uint32_t blobSize;
    /// data of size blobSize
    boost::shared_ptr<std::string> blobData;
    /// blob name length is const
    boost::shared_ptr<std::string> blobName;

    SequentialBlobDataGen(fds_uint32_t size,
                          fds_uint8_t streamId)
            : blobSize(size),
              counter(0),
              blobData(new std::string()),
              blobName(new std::string()) {
        fds_verify(blobSize >= 16);
        blobData->resize(blobSize, streamId);
        streamIdStr = std::to_string(streamId);
        streamIdStr.resize(4, '0');
        *blobName = "TestBlob_" + streamIdStr + "_00000000";
    }

    /**
     * Every time this method is called, blobData and blobName are modified
     */
    void generateNext() {
        ++counter;
        std::string counterStr = std::to_string(counter);
        counterStr.resize(8, '0');
        blobName->replace(14, 8, counterStr);
        blobData->replace(0, 8, counterStr);
    }

  private:
    /// used to generate data
    fds_uint32_t counter;
    std::string streamIdStr;
};

}  // namespace fds

#endif  // SOURCE_INCLUDE_DATAGEN_H_  // NOLINT
